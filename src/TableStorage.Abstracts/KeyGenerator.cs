using Azure.Data.Tables;

using TableStorage.Abstracts.Extensions;

namespace TableStorage.Abstracts;

/// <summary>
/// Provides key generation helper methods for Azure Table Storage entities.
/// </summary>
public static class KeyGenerator
{
    private const string PartitionKeyName = nameof(ITableEntity.PartitionKey);

    /// <summary>
    /// Generates a partition key based on the specified event timestamp, rounded to a time span interval.
    /// </summary>
    /// <param name="eventTime">The event time to base the partition key on.</param>
    /// <param name="roundSpan">The time span interval to round to. Defaults to 5 minutes if not specified.</param>
    /// <returns>
    /// A partition key string based on the rounded timestamp, formatted for reverse chronological ordering.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method creates partition keys that group entities by time intervals, which is useful for:
    /// </para>
    /// <list type="bullet">
    /// <item><description>Time-based partitioning for better query performance</description></item>
    /// <item><description>Load distribution across Azure Table Storage partitions</description></item>
    /// <item><description>Reverse chronological ordering (newest entities first)</description></item>
    /// </list>
    /// <para>
    /// The partition key is generated by rounding the timestamp to the nearest interval (default 5 minutes)
    /// and creating a 19-character string using reverse chronological ticks for optimal sorting.
    /// </para>
    /// </remarks>
    public static string GeneratePartitionKey(DateTimeOffset eventTime, TimeSpan? roundSpan = null)
    {
        var span = roundSpan ?? TimeSpan.FromMinutes(5);
        var dateTime = eventTime.ToUniversalTime();
        var roundedEvent = dateTime.Round(span);

        // create a 19 character String for reverse chronological ordering.
        return $"{DateTimeOffset.MaxValue.Ticks - roundedEvent.Ticks:D19}";
    }

    /// <summary>
    /// Generates a partition key based on the specified event timestamp, rounded to a time span interval.
    /// </summary>
    /// <param name="eventTime">The event time to base the partition key on.</param>
    /// <param name="roundSpan">The time span interval to round to. Defaults to 5 minutes if not specified.</param>
    /// <returns>
    /// A partition key string based on the rounded timestamp, formatted for reverse chronological ordering.
    /// </returns>
    /// <remarks>
    /// This overload converts the DateTime to DateTimeOffset in UTC and delegates to the primary method.
    /// </remarks>
    public static string GeneratePartitionKey(DateTime eventTime, TimeSpan? roundSpan = null)
    {
        var dateTime = eventTime.ToUniversalTime();
        var dateTimeOffset = new DateTimeOffset(dateTime, TimeSpan.Zero);

        return GeneratePartitionKey(dateTimeOffset, roundSpan);
    }


    /// <summary>
    /// Generates a row key using reverse chronological ordering with ULID for uniqueness.
    /// </summary>
    /// <param name="eventTime">The event time to base the row key on.</param>
    /// <returns>
    /// A ULID-based row key string with reverse chronological ordering (newest entities first).
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method combines the benefits of reverse chronological ordering with ULID characteristics:
    /// </para>
    /// <list type="bullet">
    /// <item><description>Reverse chronological ordering ensures newest entities appear first in queries</description></item>
    /// <item><description>ULID provides guaranteed uniqueness even for simultaneous operations</description></item>
    /// <item><description>Lexicographically sortable for efficient range queries</description></item>
    /// <item><description>High performance generation suitable for high-throughput scenarios</description></item>
    /// </list>
    /// </remarks>
    public static string GenerateRowKey(DateTimeOffset eventTime)
    {
        var dateTime = eventTime.ToUniversalTime();

        // create a reverse chronological ordering date, newest logs sorted first
        var timestamp = dateTime.ToReverseChronological();

        // use Ulid for speed and efficiency
        return Ulid.NewUlid(timestamp).ToString();
    }

    /// <summary>
    /// Generates a row key using reverse chronological ordering with ULID for uniqueness.
    /// </summary>
    /// <param name="eventTime">The event time to base the row key on.</param>
    /// <returns>
    /// A ULID-based row key string with reverse chronological ordering (newest entities first).
    /// </returns>
    /// <remarks>
    /// This overload converts the DateTime to DateTimeOffset in UTC and delegates to the primary method.
    /// </remarks>
    public static string GenerateRowKey(DateTime eventTime)
    {
        var dateTime = eventTime.ToUniversalTime();
        var dateTimeOffset = new DateTimeOffset(dateTime, TimeSpan.Zero);

        return GenerateRowKey(dateTimeOffset);
    }


#if NET6_0_OR_GREATER
    /// <summary>
    /// Generates an Azure Table Storage partition key query for the specified date.
    /// </summary>
    /// <param name="date">The date to create the query for.</param>
    /// <param name="offset">The date's offset from Coordinated Universal Time (UTC).</param>
    /// <returns>An OData filter expression for querying partition keys within the specified date range.</returns>
    /// <remarks>
    /// This method creates a query that matches all partition keys for entities within the specified date,
    /// accounting for the time zone offset when converting to UTC.
    /// </remarks>
    public static string GeneratePartitionKeyQuery(DateOnly date, TimeSpan offset)
    {
        // date is assumed to be in local time, will be converted to UTC
        var startTime = new DateTimeOffset(date.Year, date.Month, date.Day, 0, 0, 0, offset);
        var endTime = startTime.AddDays(1);

        return GeneratePartitionKeyQuery(startTime, endTime);
    }

    /// <summary>
    /// Generates an Azure Table Storage partition key query for the specified date.
    /// </summary>
    /// <param name="date">The date to create the query for.</param>
    /// <param name="zone">The time zone the date is in. Uses local time zone if not specified.</param>
    /// <returns>An OData filter expression for querying partition keys within the specified date range.</returns>
    /// <remarks>
    /// This method creates a query that matches all partition keys for entities within the specified date,
    /// using the provided time zone for proper UTC conversion.
    /// </remarks>
    public static string GeneratePartitionKeyQuery(DateOnly date, TimeZoneInfo? zone = null)
    {
        // date is assumed to be in local time, will be converted to UTC
        var startTime = date.ToDateTimeOffset(zone);
        var endTime = date.AddDays(1).ToDateTimeOffset(zone);

        return GeneratePartitionKeyQuery(startTime, endTime);
    }
#endif

    /// <summary>
    /// Generates an Azure Table Storage partition key query for the specified date range.
    /// </summary>
    /// <param name="startDate">The start date of the query range (inclusive).</param>
    /// <param name="endDate">The end date of the query range (exclusive).</param>
    /// <returns>An OData filter expression for querying partition keys within the specified date range.</returns>
    /// <remarks>
    /// This overload converts DateTime values to DateTimeOffset in UTC and delegates to the primary method.
    /// The query uses reverse chronological ordering, so the start date becomes the upper bound
    /// and the end date becomes the lower bound in the generated filter.
    /// </remarks>
    public static string GeneratePartitionKeyQuery(DateTime startDate, DateTime endDate)
    {
        var startTime = startDate.ToUniversalTime();
        var startTimeOffset = new DateTimeOffset(startTime, TimeSpan.Zero);

        var endTime = endDate.ToUniversalTime();
        var endTimeOffset = new DateTimeOffset(endTime, TimeSpan.Zero);

        return GeneratePartitionKeyQuery(startTimeOffset, endTimeOffset);
    }

    /// <summary>
    /// Generates an Azure Table Storage partition key query for the specified date range.
    /// </summary>
    /// <param name="startDate">The start date of the query range (inclusive).</param>
    /// <param name="endDate">The end date of the query range (exclusive).</param>
    /// <returns>An OData filter expression for querying partition keys within the specified date range.</returns>
    /// <remarks>
    /// <para>
    /// This method generates an OData filter expression that can be used to query Azure Table Storage
    /// for entities with partition keys in the specified date range.
    /// </para>
    /// <para>
    /// Due to reverse chronological ordering used in partition key generation, the date range logic
    /// is inverted: the start date becomes the upper bound and the end date becomes the lower bound.
    /// </para>
    /// <para>
    /// The generated query uses the format: (PartitionKey ge 'lower') and (PartitionKey lt 'upper')
    /// where 'lower' and 'upper' are 19-character reverse chronological tick values.
    /// </para>
    /// </remarks>
    public static string GeneratePartitionKeyQuery(DateTimeOffset startDate, DateTimeOffset endDate)
    {
        var startTime = startDate.ToUniversalTime();
        var endTime = endDate.ToUniversalTime();

        var upper = startTime.ToReverseChronological().Ticks.ToString("D19");
        var lower = endTime.ToReverseChronological().Ticks.ToString("D19");

        return $"({PartitionKeyName} ge '{lower}') and ({PartitionKeyName} lt '{upper}')";
    }
}
